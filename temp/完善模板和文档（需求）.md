
# 目标：

我正在整理一份repo模板，主导思想是模块化开发。我们将面向AI深度参与的项目构建repo架构，帮助实现高效的自动化编码流程，实现需求->检索->调度->编码->测试->文档->知识库的闭环。
我会提供一个公开的github代码仓库，内容为当前模板。我希望遵行以下原则改进repo模板和其中文档：
1. 以AI友好和模块化为核心导向；
2. 以自动化流程的完备程度为评价标准；
3. 融入和适配智能体编排体系，帮助大模型迅速获取关键知识、合理调用已有功能、形成更清晰的逻辑链；我会在后续章节中提供我对智能编排体系的理解，作为参考；
4. repo骨架为模板，repo中的文档需是通用文档（项目无关）。
5. 通过初始化引导，可以将此模板转换成项目repo（引导说明详见后文）。

除上述改进需求外，后序章节中也可能包含特定需求，请综合考虑。
在工作过程中，你需要基于原则1、原则2、和原则3，对需求和我的想法进行综合考量，然后按照你觉得的最佳方案进行调整。
  

## 1. 模块（Modules）
- 模块分为不同类型，相同类型的模块可以相互替换，需要保持输出输出的一致性；
- 同类型模块可以有多种不同的实现，每种具体的实现称之为模块实例；
- 每个模块实例都可以有独立的前端、后端、和核心逻辑；
- 模块分为不同级别，如一级、二级、三级等（不超过四级）。上级模块可以多个次级模块（类似树状结构）
- 模块间的关系需要单独维护

示例：
``` markdown
假设我们开发一套教辅系统，功能需求包括：作业发布、作业回收、回收情况概览、以及作业批改。
那么上述四个功能需求是四个一级模块（类型），分别将类型命名为：1_Assign，1_Collect，1_Overview，和1_Grading。

以Assign为例，在布置作业时，我们选题，组题，和发布设置三个需求。所以我们就有了二级模块，将模块类型命名为：2_Select，2_Assemble ，2_Setting。

接下来，假设选题模块中有通过Tab切换选题方式的功能，如智能出题和手动出题，那么这两类方式属于同一种模块类型，命名为：3_SelectMethod；但他们的实现方式不同，所以有两个模块实例，命令为：M_AI_Select和M_Mannul_Select。

如果现在要对M_AI_Select进行升级，则会产生一个新的模块实例M_AI_Select_2。

每个模块实例都需要单独实现功能。实例的从属关系、模板类型的说明、类型的输入输出标准，类型间包含关系、和类型间的交互关系则需要通过文档维护。
```

我想要给每个模块实例增加一个agent.md文档，帮助规范数据闭环流程，提高大模型处理效率，请你思考并给出建议。希望通过agent.md实现的目标如下：
1. 模块信息文档的维护流程。例如（只是示例，需要更加完备）：新帮建模块实例后添加哪些内容、
2. 模块开发过程中，其他文档维护流程。例如接口文档，前后端文档，项目介绍，模块实例agent.md文档等
3. 开发过程中，代码大模型正确获取的必要知识和上下文的方式和流程


## 2. 关键文档

下述几个小节是我的想法和理解，请你先进行评估，然后修正不合理的地方，补全缺失或不完善的部分，然后给出最终方案。

### README.md和agent.md的职责
我希望agent.md和README.md的职责边界更加清晰，让大模型可以明确区分README.md和agent.md的不同。

- REAMDE.md文档的内容主要包括：
	- 项目简介
	- 使用示例
	- 安装方式
	- 依赖环境
	
- REAMDE.md文档的职责主要包括：
	- 建立项目上下文
	- 识别代码入口
	- 识别整体结构

- agent.md文档的内容主要包括：
	- 角色
	- 职责
	- 边界
	- 接口
	- 依赖关系
	- 可操作范围

- agent.md文档的职责主要包括：
	- 任务分解
	- 行为约束
	- 调度方式

总结而言：README.md是项目的语义地图，更像是介绍书，主要阅读对象是人。agent.md是角色说明书和行为约束，主要阅读对象是大模型。此外，多层级目录下，应该分别维护独立的agent.md和README.md文档，以确保层级语义清晰、智能体调用和上下文明确（根目录定义政策，子文件定战术，子级覆盖父级）

### agent.md的调整

- 我希望让根目录下的agent.md文档更加轻量化，不要让大模型读取过多无用信息，思路如下：
	- 按照功能划分，agent.md维护对应文档的路径路由，让大模型在有相关需求的时候再去读对应的文档
	- 依然维护每次必读的内容，包括但不限于：全局目标、通用安全和质量门槛等
	- 分层级给出文档阅读建议，帮助大模型迅速了解所需内容：例如要了解repo级需要阅读哪些文档，要了解modules级需要阅读哪些文档

- 我希望各子目录下的agent.md文档可以更加高效的接入智能体编排体系，但缺少明确的思路。


### README.md的调整

我希望README.md文档（根目录和子目录）做出以下调整：
- 这类语义地图类的信息，如项目介绍、代码入口、骨架结构等放在文档开头；
- 在语义地图信息下方，明确README.md是用于人阅读的，编排系统或大模型应该去找同目录下的agent.md文档。


## 3. 骨架结构
请先阅读的代码仓库的repo骨架，了解现有结构。在现有基础上，我希望对骨架结构进行以下调整：
 1. 给每个模块实例增加agent.md文档和README.md文档。其中，agent.md文档用于防止上下文污染，帮助大模型理解模块边界，提高智能体编排运行效率，以及满足第1章中提到的需求；README.md文档用于模块的功能介绍和使用示例
 2. 每个模块实例新增一个doc目录(/modules/<*modules_entity>/doc)，把部分文档放到该目录下（CHANGELOG.md、CONTRACT.md、PROGRESS.md、BUGs.md、RUNBOOK.md、TEST_PLAN.md），模块实例目录下（/modules/<*modules_entity>/）只放agent.md、plan.md、和README.md;
 3. 在根目录下的doc目录（/doc/）下增加多个目录，用于承接从根目录下的agent.md文档中提取出来的内容（第2章中提到的想将agent.md轻量化）；另外增加一个目录，专门用于规范和更新模块信息（如第一章中提到的模块间关系、模块实例功能说明、模块类型定义，以及第4章中提到的模块初始化相关内容）。
 
请评估调整的合理性。  
  
## 4. 初始化引导

我希望给添加引导内容，帮助项目（repo）初始化和模块实例（modules）初始化。

### 项目初始化：
结合实际开发需求 ，对齐思路，完成项目初始化。具体计划如下：
1. 给repo模板添加初始化目录，并在TEMPLATE_USAGE.md中引导阅读初始化目录
2. 提供四种初始化方式 ：
	- 有开发文档的（要求上传）：步骤为：完善文档->达成一致->满足条件->按要求生成。过程中要鼓励讨论，帮助用户梳理思路，达成一致，收集必要信息，在条件满足后，开始初始化项目结构和必要模块
	- 无开发文档的：从头开始构建开发文档，然后转为有开发文档的项目初始化
	- 手动初始化：引导初始化解释后应做的事情，如哪些文件修改哪些内容，要哪些文件可以删除等
	- 导入其他项目：本地路径，架构复述，功能点复述，需求确认，repo结构确认，然后询问使用哪种方式迁移代码 ： 直接复制/自动实现/仅骨架（手动改赋值）
3. 初始化结束后（需要用户确认）：
	- 修改（文档）：总结项目，重写根目录下的README.md文档；根据实际repo结构，修改根目录下的agent.md文档；其他相关文档
	- 删除：初始化目录，TEMPLATE_USAGE.md

除缺少初始化目录外，更为重要的是，现有的repo没有任何文档能帮助规范项目初始化，也无法引导大模型执行正确的流程。我希望可以在初始化目录下添加一个规范化文档：
- 使大模型知道如何帮助完成项目初始化
- 要满足根目录下agent.md的要求

### 模块初始化
与项目初始化类似，模块初始化也是结合实际功能需求，初始化模块实例的过程。所以该过程的重点同样是理解需求和规范流程规。计划如下：

1. 让大模型在收到初始化要求后，根据规范文档，正确生成目录和文档
2. 询问用户是否有需求文档，如有引导放到模块实例对应的目录（modules/<*modules_entity>/doc/）下，如无则在目录下生成需求文档
3. 通过和用户交流，不断完善需求文档，确认开发需求（包括但不限于目标、功能点、作用、从属关系、隶属类型等），直到收集到足够多的信息后，要求用户确认需求文档
4. 用户确认需求文档后，按照规范文档的要求，修改相关文档（或初始化内容）
5. 完成后第4步后，询问用户是否要实现某些具体功能；如需实现，则先写目录下的plan.md文档，用户确认后开始执行代码编写。
6. 初始化结束：按照规范化文档，修改接口文档、requirements.txt、同目录下的agent.md和README.md文档、以及其他相关文档

我需要有一个通用的规范化文档（可以保存在根目录/doc/modules下，具体参考第三章）：
- 使大模型可以正确初始化模块实例，包括目录结构和必要文档
- 使大模型可以正确初始化模块实例的agent.md文档和README.md文档
- 使大模型可以准确无误的修改其他目录下的相关文档
- 需要满足根目录下agent.md的要求
  
## 5. 智能体编排参考内容
### 智能体编排（Agent Orchestration）的定义：
智能体编号不是一个模型在思考，而是多个模型或同一模型的多个实例各司其职，互相调用，按规则协作。智能体编排可以是模块级（多个Modules的编排），也可以是功能级（单个Module内部多个Agent的编排）：
- 多个具备自治目标和上下文边界的智能体
- 按定义好的角色分工，信息流，和控制逻辑
- 被一个生曾系统协调执行复杂任务过程

### agent.md文档在编排体系中职责
在智能编排体系中，agent.md就是每个智能体的自我定义文件（类似系统提示+文档），它需要告诉模型自己是谁和能干什么，并需要定义该智能体在整个Orchestration图谱中的：
- 角色（Role）；
- 输出输出（I/O schema）；
- 权限与依赖
- 上下游关系（输出哪个orchestrator，依赖谁）
- 职责边界（responsibilities）
- 限制条件（constraints）

示例：
``` markdown
# agent.md
role: "API layer coordinator"
inputs: ["HTTP requestes", "Auth tokens"]
outputs: ["validated JSON responses"]
responsibilities:
	- Route requests
	- validate payloads
	- delegate to core logic agent
constraints:
	- must not access DB directly
```
此外, agent.md必须采用结构话约定（如YAML/markdown混合），便于解析；配合统一schema进行auto-parsing，供模型上下文自动提取；保持与README.md的职责分离（详见后文）

Orchestrator应在运行时自动读取各层级目录的agent.md文档，从而实现：
- 组装整个智能体网络；
- 调用相应的Agent；
- 实现动态调度

### 典型的编排结构：

1. Orchestrator的主要功能为决策与调度（顶层），责任范围包括：
	- 读取任务目标；
	- 选择合适的子Agent；
	- 传递上下文与结果；

2. Orchestrator调度对象为Modules模块，根据自身属性，每个模块可能会包含一个或多个Agent
	- 核心逻辑（core agent），
	- 交互逻辑（UI agent），
	- 接口桥梁（API agent），
	- 数据处理（data agent），
	- 文档更新（doc agent），
	- 测试验证（test agent）；
	- 其他agent

3. 每个Agent通常：
	- 有自己的上下文（本地知识库，代码目录，agent.md），
	- 有明确的职责（在agent.md中定义），
	- 能调用工具（API，函数，模型），
	- 通过Orchestrator协调输入输出流


### 目录层级与继承约定
- 根目录/agent.md： 声明全局目标，默认模型策略，通用安全与质量门槛，路由
- 子目录（如Modules下每模块的目录）/agent.md：
	- parent： ../agent.md 集成根策略
	- 在scope.code_ownership.include中声明本模块可以改动的路径
	- 在tools_allowed/interfaces.calls中只增不减（如需要收紧权限，显示覆盖constraints）
- Orchestrator 读取从子到父合并，即子级覆盖父级
- README.md 更面向人， agent.md面向模型和编排系统
 
## 6. 其他需求
- 逐文档检查正确性，并输出一份错误报告。要求如下：
	1. 不要使用颜文字；
	2. 使用markdown等结构化输出； 
	3.  鼓励使用列表、编号、逻辑连接词；
	4.  数学场景和公式，使用标准的latex格式，行内使用单美元符号，推导和块级使用双美元符号；
	5. 提供清晰的目标说明和充足的上下文；
	6. 避免模糊的修辞，比如’有点像‘、’差不多‘；避免相近意思的重复表达
	7. 如有执行逻辑，使用明确的分布结构”
	8. 代码块可以正常识别（缩进正确，包括嵌套的代码块），章节和段落序号格式统一且没有问题
- 可能会存在模型并行开发的情况，如何解决这类冲突？是否可以参考以下方案：
	- 在plan.md中明确执行人，并在文档中规范冲突解决方案；大模型需要在用户确认plan.md中的方案后才能开始编写代码（不论是本地还是云端） 


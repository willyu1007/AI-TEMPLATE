# 修改方案调整说明

> 基于用户2025-11-07反馈的4个问题
> 更新日期：2025-11-07

---

## 1. 模块类型和实例文档维护 ✅

### 问题
模块的类型说明、模块实例的介绍、模块类型的相互关系等有文档维护吗？

### 调整方案

#### 新增文档
1. **`doc/modules/MODULE_TYPES.md`** - 模块类型说明文档
   ```markdown
   内容：
   - 模块分级概念（一级、二级、三级、四级）
   - 各类型的定义、职责、输入输出标准
   - 类型间的包含关系（树状结构图）
   - 同类型模块的可替换性说明
   - 示例：教辅系统的1_Assign → 2_Select → 3_SelectMethod
   ```

2. **`doc/modules/MODULE_INSTANCES.md`** - 模块实例目录
   ```markdown
   内容：
   - 所有模块实例的索引和简介
   - 每个实例的：类型、路径、状态、版本、责任人
   - 实例间的依赖关系（upstream/downstream）
   - 从registry.yaml自动生成（make module_doc_gen）
   ```

#### 新增命令
```makefile
module_doc_gen:
	@python scripts/module_doc_gen.py
	@echo "✅ 模块文档已生成: doc/modules/MODULE_INSTANCES.md"
```

#### 维护流程
1. **模块类型定义**：在`doc/modules/MODULE_TYPES.md`手动维护
2. **模块实例信息**：
   - 在`doc/orchestration/registry.yaml`维护（半自动化）
   - 运行`make module_doc_gen`生成`MODULE_INSTANCES.md`
3. **大模型初始化模块时**：
   - 读取MODULE_TYPES.md了解类型定义
   - 询问用户该模块属于哪个类型
   - 自动更新registry.yaml
   - 生成MODULE_INSTANCES.md

---

## 2. 根目录整洁方案 ✅

### 问题
根目录需要更整洁，有无整合方案？

### 当前状态
```
根目录文件（9个）：
- agent.md, README.md, QUICK_START.md, TEMPLATE_USAGE.md
- CONTRIBUTING.md, LICENSE, Makefile, requirements.txt, docker-compose.yml

根目录目录（12个）：
ai/, common/, config/, docs/, evals/, flows/, migrations/,
modules/, observability/, scripts/, tests/, tools/
```

### 调整方案

#### 目录整合
```text
调整项：

1. docs/ → doc/
   - 统一命名（方案中用doc/）
   - 与新增的doc/orchestration/等一致

2. flows/ → doc/flows/
   - 流程图属于文档范畴
   - dag.yaml移动到doc/flows/dag.yaml
   - 更新所有引用该路径的代码和文档

3. migrations/ → db/engines/postgres/migrations/
   - Phase 5执行（数据库治理）
   - 根目录保留migrations/作为兼容别名（README指向新路径）

4. tools/ 保持不变
   - 存放"工具的契约定义"（contract.json）
   - 语义明确，不改名
```

#### 最终根目录
```
根目录文件（9个，不变）：
- agent.md, README.md, QUICK_START.md, TEMPLATE_USAGE.md
- CONTRIBUTING.md, LICENSE, Makefile, requirements.txt, docker-compose.yml

根目录目录（12个）：
ai/, common/, config/, doc/, db/, evals/, modules/,
observability/, schemas/, scripts/, tests/, tools/

更整洁：
- doc/统一了所有文档（包含flows/）
- db/统一了数据库相关（Phase 5后migrations/变为别名）
- schemas/明确存放Schema定义
```

#### 实施顺序
1. **Phase 2**：创建doc/子目录，暂不改名docs/
2. **Phase 3**：docs/ → doc/（改名，更新所有引用）
3. **Phase 3**：flows/ → doc/flows/（移动，更新引用）
4. **Phase 5**：migrations/ → db/engines/postgres/migrations/（移动，保留别名）

---

## 3. 模块实例内部结构规范 ✅

### 问题
需要明确每个模块实例的具体实现放到自己的目录下（前后端、核心逻辑等），并在合适的文档里增加功能和接口说明。

### 调整方案

#### 模块实例标准目录结构
```text
modules/<entity>/
├── agent.md              # 模块实例agent.md（YAML+MD）
├── README.md             # 模块说明（人读）
├── plan.md               # 开发计划
│
├── doc/                  # 文档子目录
│   ├── CHANGELOG.md      # 变更日志
│   ├── CONTRACT.md       # 接口契约：所有对外API、输入输出
│   ├── PROGRESS.md       # 进度跟踪
│   ├── BUGS.md           # 缺陷管理
│   ├── RUNBOOK.md        # 运维手册
│   └── TEST_PLAN.md      # 测试计划
│
├── core/                 # 核心业务逻辑（必需）
│   ├── __init__.py
│   ├── service.py        # 核心服务类
│   └── processor.py      # 业务处理器
│
├── api/                  # API层（可选，如有HTTP接口）
│   ├── __init__.py
│   ├── routes.py         # 路由定义
│   └── handlers.py       # 请求处理器
│
├── frontend/             # 前端（可选，如模块有独立前端）
│   ├── components/       # Vue/React组件
│   ├── views/            # 页面视图
│   ├── main.ts           # 入口文件
│   └── README.md         # 前端说明
│
├── models/               # 数据模型（可选）
│   ├── __init__.py
│   ├── entities.py       # 实体定义
│   └── schemas.py        # 数据Schema
│
├── utils/                # 工具函数（可选）
│   ├── __init__.py
│   └── helpers.py        # 辅助函数
│
└── tests/                # 模块级测试（可选）
    ├── test_core.py
    └── test_api.py

注：也可将tests/放在根tests/<entity>/下
```

#### 各子目录说明

| 子目录 | 必需性 | 职责 | 示例内容 |
|--------|-------|------|---------|
| doc/ | 必需 | 所有文档 | CONTRACT.md等6个文档 |
| core/ | 必需 | 核心业务逻辑 | 服务类、处理器、算法实现 |
| api/ | 可选 | HTTP接口层 | 路由定义、请求处理 |
| frontend/ | 可选 | 前端代码 | 组件、视图、样式 |
| models/ | 可选 | 数据模型 | 实体类、Schema定义 |
| utils/ | 可选 | 工具函数 | 辅助函数、通用逻辑 |
| tests/ | 可选 | 模块测试 | 单元测试、集成测试 |

#### 信息记录位置

| 信息类型 | 记录位置 | 内容要点 |
|---------|---------|---------|
| **功能概述** | README.md | • 模块做什么<br>• 适用场景<br>• 核心能力<br>• 与其他模块的关系 |
| **目录结构** | README.md | • 各子目录职责<br>• 代码入口<br>• 关键文件说明 |
| **接口定义** | doc/CONTRACT.md | • 所有对外API<br>• 请求/响应格式<br>• 错误码<br>• 调用示例 |
| **数据模型** | doc/CONTRACT.md | • 输入输出结构<br>• 字段说明<br>• 验证规则<br>• 示例数据 |
| **内部架构** | README.md | • 核心组件<br>• 数据流<br>• 设计模式<br>• 架构图（可选） |
| **技术栈** | README.md | • 依赖库<br>• 框架版本<br>• 环境要求 |
| **配置项** | README.md + doc/RUNBOOK.md | • 环境变量<br>• 配置参数<br>• 默认值 |
| **部署运维** | doc/RUNBOOK.md | • 启动命令<br>• 监控指标<br>• 故障排查 |

#### 在doc/modules/MODULE_INIT_GUIDE.md中增加

**新增章节：模块实例代码组织规范**

```markdown
## 模块实例代码组织

### 标准目录结构
（贴上上面的结构图）

### 大模型创建模块时的行为规范
1. **询问模块特性**：
   - 是否有HTTP接口？（决定是否创建api/）
   - 是否有独立前端？（决定是否创建frontend/）
   - 是否有数据模型？（决定是否创建models/）

2. **创建必需目录**：
   - agent.md, README.md, plan.md（根级）
   - doc/（6个文档）
   - core/（核心逻辑）

3. **创建可选目录**：
   - 根据步骤1的询问结果创建

4. **填写README.md**：
   - 功能概述章节
   - 目录结构章节（说明各子目录职责）
   - 技术栈章节

5. **填写doc/CONTRACT.md**：
   - API接口定义章节
   - 数据模型章节
   - 调用示例章节
```

#### 示例：更新modules/example/

Phase 4执行时，为example模块补齐内部结构：
```text
modules/example/
├── agent.md
├── README.md（更新：增加"目录结构"章节）
├── plan.md
├── doc/（6个文档）
├── core/（新增）
│   ├── __init__.py
│   └── service.py
├── api/（新增）
│   ├── __init__.py
│   └── routes.py
└── models/（新增）
    ├── __init__.py
    └── schemas.py
```

---

## 4. schemas与scripts目录关系 ✅

### 问题
schemas和当前的scripts是不是功能重复？如是可自行整合（Phase 1）。

### 分析

#### schemas/目录
**作用**：存放Schema定义（规范/标准）
```text
schemas/
├── agent.schema.yaml       # agent.md的YAML前言Schema
├── registry.schema.yaml    # registry.yaml的Schema（可选）
└── db/                     # 数据库Schema（可选）
    └── table.schema.yaml   # 表结构YAML的Schema
```

#### scripts/目录
**作用**：存放可执行脚本（实现/工具）
```text
scripts/（当前20个脚本）
├── agent_lint.py           # 使用schemas/agent.schema.yaml校验
├── registry_check.py       # 校验registry.yaml
├── dag_check.py           # DAG校验
├── docgen.py              # 文档生成
├── ...（其他脚本）
```

#### tools/目录
**作用**：存放工具的契约定义
```text
tools/
├── codegen/
│   └── contract.json      # codegen工具的接口契约
└── openapi.json           # OpenAPI规范（自动生成）
```

### 结论：不重复，互补关系

- **schemas/** = 定义（规范/Schema）- 被scripts/使用
- **scripts/** = 实现（脚本）- 使用schemas/中的定义
- **tools/** = 工具契约 - 独立的接口定义

**关系图**：
```
schemas/agent.schema.yaml
    ↓ (被使用)
scripts/agent_lint.py → 读取agent.md → 校验YAML前言

doc/orchestration/registry.yaml
    ↓ (被校验)
scripts/registry_check.py → 校验完整性和一致性
```

### 整合方案：保持独立，明确职责

#### Phase 1执行计划（调整）

**不从Enhancement-Pack直接复制，而是参考后自行实现**

1. **创建schemas/目录**（30分钟）
   ```bash
   mkdir -p schemas
   mkdir -p schemas/db
   ```

2. **创建agent.schema.yaml**（1-2小时）
   - 参考Enhancement-Pack的结构
   - 根据当前repo的agent.md实际需要调整字段
   - 必填字段：spec_version, agent_id, role, context_routes
   - 可选字段：level, module_type, ownership等

3. **编写agent_lint.py**（2-3小时）
   - 参考Enhancement-Pack的逻辑
   - 适配当前repo的路径结构
   - 遍历当前repo的agent.md位置：
     * 根目录agent.md
     * modules/*/agent.md（未来）
   - 使用jsonschema库校验
   - 输出友好的错误报告

4. **编写registry_check.py**（2-3小时）
   - 校验doc/orchestration/registry.yaml
   - 检查：
     * 实例ID唯一性
     * agent_md路径存在性
     * 依赖关系无环（DAG检测）
     * module_type引用的类型存在
   - 输出错误报告

5. **编写doc_route_check.py**（1-2小时）
   - 遍历所有agent.md
   - 提取context_routes中的路径
   - 检查路径是否存在
   - 输出缺失路径列表

6. **编写registry_gen.py**（2-3小时）
   - 扫描modules/目录
   - 读取每个模块的README.md和agent.md（如有）
   - 生成registry.yaml草案
   - 标记需要人工补充的字段

7. **Makefile新增命令**（1小时）
   ```makefile
   # 校验命令
   agent_lint:
       @echo "🔍 校验agent.md..."
       @python scripts/agent_lint.py || echo "⚠️  警告模式，允许失败"
   
   registry_check:
       @echo "🔍 校验registry.yaml..."
       @python scripts/registry_check.py || echo "⚠️  警告模式，允许失败"
   
   doc_route_check:
       @echo "🔍 校验文档路由..."
       @python scripts/doc_route_check.py || echo "⚠️  警告模式，允许失败"
   
   # 生成命令
   registry_gen:
       @echo "📝 生成registry.yaml草案..."
       @python scripts/registry_gen.py
       @echo "✅ 草案已生成: doc/orchestration/registry.yaml.draft"
       @echo "   请审核并重命名为 registry.yaml"
   
   module_doc_gen:
       @echo "📝 生成模块实例文档..."
       @python scripts/module_doc_gen.py
       @echo "✅ 已生成: doc/modules/MODULE_INSTANCES.md"
   ```

8. **更新scripts/README.md**（30分钟）
   - 新增脚本说明
   - 说明schemas/与scripts/的关系

#### tools/目录处理

**决策：保持不变**
- tools/存放"工具的契约定义"（contract.json）
- 语义明确："工具的接口规范"
- 不改名，不移动

---

## 总结：4项调整对Phase的影响

### Phase 1（3-5天）→ Phase 1（4-6天）
- 新增：编写4个脚本（不复制）
- 新增：schemas/目录和agent.schema.yaml
- 调整：Makefile新增5个命令

### Phase 2（5-7天）→ Phase 2（6-8天）
- 新增：doc/modules/MODULE_TYPES.md
- 新增：doc/modules/MODULE_INSTANCES.md
- 新增：docs/ → doc/（改名，更新引用）
- 新增：flows/ → doc/flows/（移动，更新引用）

### Phase 3（3-5天）→ 不变
- 根agent.md轻量化

### Phase 4（3-5天）→ Phase 4（4-6天）
- 新增：为example模块补齐内部结构（core/, api/, models/）
- 新增：更新example/README.md（目录结构章节）
- 新增：更新example/doc/CONTRACT.md（接口定义章节）

### Phase 5-8（12-16天）→ 不变

### 总工作量
- 原：15-25天
- 调整后：17-28天（增加2-3天）

---

---

## 5. app/frontend与modules的职责划分（第5个问题） ✅

### 问题
按照当前agent.md的说法，根目录可能还会维护app和frontend，这两个目录和modules下的相关目录的职责划分需要明确。

### 详细说明

已创建**`temp/app_frontend_职责划分说明.md`**(753行)，详细说明了：

#### 5.1 核心原则
```
根目录app/frontend/ = 应用层
    - 职责：入口、路由分发、全局中间件、通用组件
    - 不含：业务逻辑

modules/<entity>/api/frontend/ = 模块层
    - 职责：模块特定的业务实现
    - 包含：该模块的具体功能实现
```

#### 5.2 调用关系
```
app/ → modules/<entity>/api/ → modules/<entity>/core/
frontend/ → modules/<entity>/frontend/ → API调用
```

#### 5.3 判断标准

**模块是否需要api/子目录？**
- 该模块对外提供HTTP接口？→ 是 → 创建api/
- 纯内部模块？→ 否 → 不创建api/，仅有core/

**模块是否需要frontend/子目录？**
- 该模块有特定的UI页面或组件？→ 是 → 创建frontend/
- 纯后端模块或使用通用组件？→ 否 → 不创建frontend/

#### 5.4 文档记录要求
- **README.md**: 必须有"目录结构"章节，说明各子目录职责
- **doc/CONTRACT.md**: 区分API接口和前端组件说明

#### 5.5 大模型初始化行为
在MODULE_INIT_GUIDE.md中规范：
1. 询问："该模块是否对外提供HTTP接口？"
2. 询问："该模块是否有特定的前端页面或组件？"
3. 根据回答创建相应子目录

### 实施影响

#### Phase 2增加内容
在创建doc/modules/MODULE_INIT_GUIDE.md时，增加：
- "模块子目录创建规范"章节
- "职责边界检查"章节

#### Phase 3增加内容
在轻量化根agent.md时，在§1目录规范中增加：
- §1.3 "应用层与模块层的职责边界"
- 包含：职责划分总则、代码放置决策、典型目录对照表

#### Phase 4增加内容
为modules/example/补齐内部结构时：
- 创建core/子目录（必需）
- 根据example的特性决定是否创建api/和frontend/
- 在README.md中增加"目录结构"章节，详细说明各子目录职责

---

## 下一步

请确认以上**5项调整**是否满足需求：
1. ✅ 新增MODULE_TYPES.md和MODULE_INSTANCES.md维护模块类型和实例
2. ✅ 根目录整洁：docs/→doc/, flows/→doc/flows/
3. ✅ 明确模块实例内部结构（core/, api/, frontend/等）和文档记录位置
4. ✅ schemas/和scripts/保持独立，不复制而是参考后自行实现
5. ✅ **app/frontend与modules的职责划分明确**（详见app_frontend_职责划分说明.md）

确认后即可开始Phase 1执行。


